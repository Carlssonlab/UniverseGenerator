std::pair<std::vector<unsigned int>,std::vector<unsigned int>> is_activated_bond(const RDKit::ROMol &mol, const RDKit::Bond &bond)
{

    std::vector<unsigned int> tag_numbers = {75u,76u};

    //
    std::vector<unsigned int> bgn_activators = {};
    std::vector<unsigned int> end_activators = {};

    //
    std::vector<unsigned int> bgn_isotopes = {};
    std::vector<unsigned int> end_isotopes = {};

    // Get the atoms forming the bond
    const RDKit::Atom *bond_bgn = bond.getBeginAtom();
    const RDKit::Atom *bond_end = bond.getEndAtom();

    // Iterate over all neighboring atoms
    for(const auto &neighbor_atom: mol.atomNeighbors(bond_bgn))
    {
        //
        const unsigned int neighbor_atom_elem = neighbor_atom->getAtomicNum();
        const unsigned int neighbor_isotope = neighbor_atom->getIsotope();

        //
        if (count(tag_numbers.begin(), tag_numbers.end(), neighbor_atom_elem) > 0)
        {
            //std::cout << "Tag!" << std::endl;
            bgn_activators.emplace_back(neighbor_atom_elem);
            bgn_isotopes.emplace_back(neighbor_isotope);
        }   
    }

    // Iterate over all neighboring atoms
    for(const auto &neighbor_atom: mol.atomNeighbors(bond_end))
    {
        //
        const unsigned int neighbor_atom_elem = neighbor_atom->getAtomicNum();
        const unsigned int neighbor_isotope = neighbor_atom->getIsotope();

        //
        if (count(tag_numbers.begin(), tag_numbers.end(), neighbor_atom_elem) > 0)
        {
            //std::cout << "Tag!" << std::endl;
            //
            end_activators.emplace_back(neighbor_atom_elem);
            end_isotopes.emplace_back(neighbor_isotope);
        }   
    }

    // If either of the atoms has no tags, the bond is not activated
    if (bgn_activators.size() == 0 || end_activators.size() == 0)
    {
        // The bond is not activated
        return std::make_pair(std::vector<unsigned int>(),std::vector<unsigned int>());
    }
    
    // Sort the activator tag vectors
    std::sort(bgn_activators.begin(), bgn_activators.end());
    std::sort(end_activators.begin(), end_activators.end());

    // Sort the isotope vectors
    std::sort(bgn_isotopes.begin(), bgn_isotopes.end());
    std::sort(end_isotopes.begin(), end_isotopes.end());
    
    /*
    for (const unsigned int& num : bgn_isotopes)
    {
        std::cout << num << "\t";
    }
    std::cout << std::endl;

    for (const unsigned int& num : end_isotopes)
    {
        std::cout << num << "\t";
    }
    std::cout << std::endl;
    */

    // What does this do?
    bgn_activators.erase(std::unique(bgn_activators.begin(), bgn_activators.end()), bgn_activators.end());
    end_activators.erase(std::unique(end_activators.begin(), end_activators.end()), end_activators.end());
    
    bgn_isotopes.erase(std::unique(bgn_isotopes.begin(), bgn_isotopes.end()), bgn_isotopes.end());
    end_isotopes.erase(std::unique(end_isotopes.begin(), end_isotopes.end()), end_isotopes.end());
    
    // Template syntax : std::includes(vec1.begin(), vec1.end(), vec2.begin(), vec2.end())
    //if (std::equal(bgn_activators.begin(), bgn_activators.end(), end_activators.begin()) && \
    //    std::equal(bgn_isotopes.begin(), bgn_isotopes.end(), end_isotopes.begin()))
    
    std::vector<unsigned int> small_activators;
    std::vector<unsigned int> large_activators;
    std::vector<unsigned int> small_isotopes;
    std::vector<unsigned int> large_isotopes;
    if (bgn_activators.size() > end_activators.size())
    {
        //std::cout << "is larger" << std::endl;
        small_activators = end_activators;
        large_activators = bgn_activators;
    }
    else
    {
        //std::cout << "is smaller" << std::endl;
        small_activators = bgn_activators;
        large_activators = end_activators;
    }
    if(bgn_isotopes.size() > end_isotopes.size())
    {
        small_isotopes = end_isotopes;
        large_isotopes = bgn_isotopes;
    }
    else
    {
        small_isotopes = bgn_isotopes;
        large_isotopes = end_isotopes;
    }
    bool is_subset_activators = true;
    bool is_subset_isotopes = true;
    
    //std::cout << "s_a: " << small_activators.size() << std::endl;
    //std::cout << "l_a: " << large_activators.size() << std::endl;
    //std::cout << "s_i: " << small_isotopes.size() << std::endl;
    //std::cout << "l_i: " << large_isotopes.size() << std::endl;

    for (const unsigned int& act_num : small_activators)
    {
        if (count(large_activators.begin(), large_activators.end(), act_num) == 0)
        {
            is_subset_activators = false;
            //std::cout << "not subset activators" << std::endl;
            break;
        }
    }
    for (const unsigned int& iso_num : small_isotopes)
    {
        if (count(large_isotopes.begin(), large_isotopes.end(), iso_num) == 0)
        {
            is_subset_isotopes = false;
            //std::cout << "not subset isotopes" << std::endl;
            break;
        }
    }
    
    //
    if (is_subset_isotopes && is_subset_activators)
    {
        //std::cout << bond.getIdx() << " Is activated !!!" << std::endl;
        return std::make_pair(bgn_activators,end_activators);
    }    
    else
    {
        //std::cout << bond.getIdx() << " Not activated !!!" << std::endl;
        // The bond is not activated
        return std::make_pair(std::vector<unsigned int>(),std::vector<unsigned int>());
    }
}
